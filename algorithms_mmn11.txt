Question 1

Overview
The given problem can be adapted to make use of the GS algorithm:
Define the “men” as the ships, such that each ship's priorities list is its schedule, with the first port having the highest priority.
Define the "women" as the ports, such that each port's priorities list is its schedule, with the last visiting ship having the highest priority.

Pseudo-code

BUILD-SHIP-SCHEDULE( LS : a list of ships and their schedule )
	We start with all ships and harbors unassigned
	While there’s a ship which doesn’t have a final port assigned:
		Choose such a ship S
		Let P be the first port in S’s schedule, of which S didn't ask terminal dock permission
		If P is free:
			dock S at P
		Else:
			If P prefers S to the current docked ship:
				dock S at P instead
	crop each ship's schedule after arriving at its terminal port
	return a list of the cropped schedules


Proof of Correctness
First off, there are n ships and n ports. With elements of both types having a ranking for each element of the other type.
Thus, GS can be used to produce a stable matching for our input.

Let's formalize the definition of our algorithm being correct:
Under the constraints of the problem, for every given a valid input of ships and schedules, the output will be a list of new schedules
consisting of the original schedules up to some port, and cropped thereafter in such a way as to avoid any two ships docking in the same port on the same day.

Proposition:
A stable matching between all the ships and ports results in a correct schedule for all ships.

Proof:
Suppose our proposition is false: after running the algorithm the output is not valid under the constraints in the problem.
Then there exist two ships, S_1 and S_2, such that S_1 enters its terminal port P_1, before S_2 enters P_1.
But in such a case, according to outlined algorithm, S_2 prefers P_1 (since it's earlier on its schedule) and P_1 prefers S_2
(since P_1 comes later in S_2's schedule). Therefore, this schedule couldn't have been generated by our algorithm - contradiction!
We conclude that the algorithm will always produce a valid schedule under the given constraints - the algorithm is correct.

Complexity
Running GS takes O(n^2). Cropping the schedule of a ship takes O(m), we do this n times (for each ship).
Overall the time complexity is O(n*m) (because m>=n).


Question 2

Overview

A graph can be directed iff there exists a cycle in every connected component.
If it can, direct all the backtracking edges until an undirected tree remains.
Then, proceed to direct the leaf nodes until the whole graph is directed.


Pseudo-code

BUILD_DIRECTED_GRAPH( G(V,E) : an undirected graph )
	init a directed graph H with all of G's vertices and no edges
    find all the connected components of G
	for each connected component G’ =(V’,E’)  in G:
	    Apply a BFS scan thus:
            if an edge (u,v) is found, such that v is in explored and is not u's parent:
                add the directed edge u<-v to H
                delete the edge from G
            if no such edge is found when the scan concludes:
                return false
        while there exists a vertex v such that d(v)=1:
            direct its only edge into v, delete it from G, add it to H
	return H


Proof of Correctness

If a connected component doesn't have a cycle, then it has less edges then vertices. Therefore, there will always be at least one vertex v with d_in(v)=0.
If we remove all backtracking edges from a connected component, a tree is left. Otherwise, if it's not a tree, then it has a cycle, contradiction!
Iteratively removing all leaves of a tree, will eventually remove the entire tree - trivial.

Complexity
Finding the strongly connected components, directing the cycles, directing the trees - each task is O(n+m)
Overall the algorithm runs in O(n+m) time.


Question 3

Overview
The algorithm builds a directed implications graph for all the literals in the formula.
If a literal and its negation are found in the same strongly connected component, no assignment is possible.
Building an assignment is done by assigning each literal which implies its negation as false, and otherwise assign it as true.

Pseudo-code

FIND-2-SAT-ASSIGNMENT( F: a 2-CNF )
    init a directed graph G with no edges, and its vertices being the literals and their negations
    init the assignment list LA
    for each statement in F and its literals q,p:
        Add the directed edges !p - > q and !q -> p to G
    while there's an un-unassigned vertex v:
        find all v's children in the graph //BFS
        if one of v's children is !v:
            find all !v's children in the graph //BFS
                if one of !v's children is v:
                    return false
                else:
                    assign all !v's children as true
                    assign all v's children as false
        else:
            assign all v's children as true
            assign all !v's children as false
    return  a list of literals and their assignments


Proof of Correctness

1) The statement (q or p) is equivalent to (!q -> p and !p -> q). Proven by building a truth table.

2) Given some 2-CNF, If there exists a literal such that p -> !p and !p -> p, then it's not satisfiable. If it were satisfiable, then x <-> !x is true, contradiction!

3) If a literal p is true, then there is no path p -> q and p -> !q. If there were, then p -> !q -> !p, which would make p false.


Complexity
We're given a formula with n clauses, with each clause having 2 literals (2-SAT).
Therefore, our graph has at most m=2n vertices and edges.
Building the graph is an O(m) task.
Building an assignment is a 2O(m) task.
Overall the algorithm has a time complexity of O(m)


Question 4

Overview

Divide G into 2 components: U, and W=V/U.
Construct a new graph such as to allow BFS to scan nodes more than once while still reaching the goal state and ensure termination.

Pseudo-code

FIND-2U-SHORTEST-PATH( G=(V,E), U)
    init an empty directed graph H
    init 5 empty sub-graphs of H: W_1, U_1, W_2, U_2, W_3
    for each vertex v in G:
       if v is in U:
            add 2 copies of v to H: v_1 to U_1, v_2 to U_2
       else:
            add 3 copies of v to H: v_1 to W_1, v_2 to W_2, v_3 to W_3
    for each edge e in G:
        if e is an edge from V/U to U:
            add it as an edge from W_1 to U_1, and from W_2 to U_2
        if e is an edge from U to U:
            add it as an edge from U_1 to U_2
        if e is an edge from U to V/U:
            add it as an edge from U_1 to W_2, and from U_2 to W_3
        if e is an edge from V/U to V/U:
            add it as an edge from each of W_1, W_2, W_3, to itself.
    start a BFS scan to find a path from W_1.s to W_3.t
    if such a path doesn't exist:
        return false
    else:
        return the path found by BFS


Correctness
1) The returned path passes through U exactly twice. U_1, U_2 have no internal edges and there's no cycle between the sub-graphs.
    Therefore, a path from W_1 to W_3 will pass through U_1 exactly once and U_2 exactly once.

2) The returned path is the shortest path. It's a property of BFS when searching through an unweighted graph.

3) The returned path is a valid path through G. Every edge in H is an edge in G and every vertex in H is a vertex in G.

Complexity
Building the graph H with its sub-graphs - O(n+m)
Finding the shortest path - O(m+n)
Overall the algorithm runs in O(m+n) time.










